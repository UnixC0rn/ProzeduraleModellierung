
\begin{document}
\pagenumbering{roman}
\pagestyle{plain}


\section*{​\textcolor{​rosa}​{​Nodes:}​}​
\subsection*{​Attribute:}​
\subsubsection*{​Attribute Blur:}
Verwischt Gleitkommaattribute, einschließlich Position, Farbe und Texturkoordinaten, von Punkten in einem Netz, wodurch eine Geometrie effektiv geglättet wird.
\begin{itemize}
\item Attributes	Welche Attribute verwischt werden sollen, wenn das Feld leer ist, macht die Node nichts
\item Method \begin{itemize} 
		\item Uniform - verwischt gleichmäßig
		\item Edge Length - verwischt mit Wissen das manche punkte näher sind als andere und behält ihre Abstände bei 
		\end{itemize}
\item Mode	\begin{itemize} 
		\item Laplacian - jede Iteration hat dieselbe Größe die durch "step size" definiert wird
		\item Volume Preserving - Iterationsgrößen werden basierend auf einer Rauschfrequenz ausgewählt, die durch "Cutoff Frequency" ausgewählt wird
		\item Custom	Benutzer - kann die Iteration Größen von geraden und ungeraden manuell angeben	
		\end{itemize}
\item Influence Type 
		\begin{itemize}
		\item Connectivity - Punkte mischen ihre Attributwerte mit den ihrer Nachbarn, die durch  Mesh-Konnektivität (Verbindungsfähigkeit) erkannt werden
		\item Proximity - Nachbarn werden durch die nähe bestimmt 
			\begin{itemize}
			\item Max - max. Anzahl der Nachbarn
			\item Proximity Radius - max. Entfernung der Nachbarn
			\end{itemize}
		\end{itemize}
\end{itemize}

\subsubsection*{​Attribute create:}
Erstellt Attribute der Typen float, Integer, Vector oder String. Falls kein Variablen Name genannt wird, wird der Attribute Name genommen (Groß Buchstaben).
Value: Stamp ()	gibt eine stamping Variable eine meist danach liegenden Copy Node zurück

\subsubsection*{​Attribute transfer:}
Überträgt Scheitelpunkt-, Punkt-, Grundelement- und/oder Detailattribute zwischen zwei Modellen.
Die Übertragung funktioniert durch nähe und überträgt Attribute von einem Geometrie Teil auf die nächstliegende Punkte auf einem anderen Geometrieteil. 
unter Attribute kann man die jeweiligen Attribute festlegen. Wenn das Feld leer oder ein Sternchen beinhaltet werden alle verfügbaren Attribute übertragen.
\begin{itemize}
\item Conditions - gibt an wie Quellattribute kombiniert oder gefiltert werden
\item Distance Threshold- gibt die maximale Entfernung von Quellpunkten/Primitiven an, die berücksichtigt werden müssen
\item Blend Width - lockert den Distance Treshold und legt optional einen Bereich außerhalb des Distance Treshold fest, in dem der Einfluss der Quellattribute allmählich nachlässt.
\end{itemize}

\subsubsection*{​Attribute VOP:}
Innerhalb der Node (Doppelklick auf die Node) befindet sich ein VOP Netzwerk. Mit Hilfe von Mathematischen Nodes (z.B. Multiply) lassen sich Attribute Modifizieren.
genutzte Nodes:
\begin{itemize}
\item geometryvopglobal 	alle globalen Variablen für die Attribut-VOP-Netzwerktypen
	\begin{itemize}
	\item p - Position des aktuellen Elements
	\item ptnum (pointnumber) - aktuell verarbeiteter Punkt 
	\item numpt (number points) - Gesamtanzahl der Punkte
	\end{itemize}
\item divconst - dividiert eingehenden wert durch angegebenen konstanten Wert (Divider)
\item divide - Division jedes Eingabewerts durch den nächsten 
\item multiply	 - gibt das Produkt der Inputs aus
\item inttofloat - wandelt integer zu float um
\item vectofloat - wandelt einen Vector zu einer float Zahl um
\item floattovec - wandelt eine float Zahl zu einem Vector um
\item bind - Bindet die Geometrie an die VEX Funktion um Attribute aufrufe zu können
\item ramp- ramp user interface. Der Input ist die Position in der Rampe von dem Wert, welche die Node ausgibt
\item turbnoise - berechnet rauschen mit der Fähigkeit, Turbulenzen mit Rauheit und Dämpfung zu berechnen
\item displacenml - Verschiebt die Fläche entlang der Flächennormalen um einen bestimmten Betrag
\item geometryvopoutput - Platzhalter, um Attribut-VOP-Netzwerktypen herauszuschreiben
\end{itemize}

\subsubsection*{​Attribute wrangle:}
entspricht der attribvop Node, aber anstatt des VOP Netzwerks werden hier VEX code Schnipsel genutzt. VEX(Vector Expression Language) ist die Coding Sprache die innerhalb Houdini Verwendet wird und auf C/C++ basiert.
Innerhalb des VEXpressions Fenster kann gecodet werden.
Verwendeter VEX Code
 @ repräsentiert Attribute:
\begin{itemize}
\item @Cd - colour (diffuse) 
\item @ptnum - aktuell verarbeiteter Punkt
\item @pscale - steuert die Größe (Skalierung) der Punkte
\item @elemnum - Nummer des Aktuellen Elements
\item @numpt - Gesamtanzahl der Punkte
\item @np - die Input Nummer
\item @rot - Rotation
\item @sc - Skalierung
\item @Time - float Time(\$T)
\end{itemize}

Der Buchstabe bevor dem @ repräsentiert den Datentyp 
\begin{itemize}
\item f@name - float
\item i@name - integer
\end{itemize}

Funktionen:
\begin{itemize}
\item addpoint()	int  addpoint(int geohandle, int point_number)
fügt Punkte einer Geometrie dazu
geohandle 	Geometrie, in die der Punkt hinzugefügt werden soll
		momentan ist der einzig gültige Wert 0 (oder geoself), was die aktuelle Geometrie in der Node bedeutet
\item setpointattrib()int  	setpointattrib(int geohandle, string name, int point_num, <type>value, string mode="set")
Legt ein Punktattribut in einer Geometrie fest
	\begin{itemize}
	\item name 		Attribut welches festgelegt werden soll
	\item point_num 	Nummer des Punktes auf dem das Attribut gesetzt wird
	\item value 		Wert des Attributes
	\item mode 		(Optional)
			wenn angegeben, steuert wie die Funktion jeden vorhanden Wert im Attribut ändert 
			"set" überschreibt das Attribut mit dem angegebenen Wert	 	
	\end{itemize}						
					
\item ch() 	float  chf(string channel)
		Wertet einen Channel oder Parameter aus und gibt seinen Wert zurück
		Buchstabe nach dem ch gibt Datentyp an 
		f -> float
		ramp -> ramp
 		float  	chramp(string channel, float ramppos)
			wertet einen Ramp Parameter aus und gibt seinen Wert zurück	
			ramppos 	stelle auf der Rampe, die ausgewertet werden soll
		mit ch() erstellte kann man durch klicken von "Creates spare parameters for each unique call of ch()" anzeigen lassen und bearbeiten
		\includegraphics*[width=\textwidth]{graphics/attribVOPramp.JPG}
		
\item noise()		Es gibt zwei Arten von noise: ändert sich zufällig im gesamtem N-dimensionalen Raum
			nicht periodisches noise: wiederholt sich in einem gegeben Zeitraum
			Die Funktion bestimmt die art:
			vector/float noise(float pos) ->1D noise	
			vector/float noise(float posx, float posy) ->2D noise
			vector/float noise(vector pos) ->3D noise
			vector/float noise(vector4 pos) ->4D noise
			man bekommt entweder einen Vector aus 3 Zahlen oder eine zufällige float
\end{itemize}

\subsection*{​Digital Assets:}​
\subsection*{​Group:}​
\subsubsection*{​Group Create:}
Erzeugt Gruppen von Punkten, Primitiven, Kanten oder Scheitelpunkten nach verschiedenen Kriterien.
\begin{itemize}
\item Base Group	\begin{itemize}
		Base Group	- gruppierende Muster, behandelt normale adhoc-Gruppen (keine dauerhafte gruppe, nur unmittelbar zur Lösung eines bestimmten Problems gebildet) Syntax
		create ordered - ordnet die Gruppe
		\end{itemize}
\item Keep in Bounding Regions 
		\begin{itemize}
		\item Enable	- Gruppieren nach begrenzungsvolumen
		\item Bounding Type - Form des begrenzungsvolumen
		\item Size - Größe des begrenzungsvolumen
		\item Center - Mitte des begrenzungsvolumen
		\item Iso - Iso Fläche des Volumens, welche Gruppiert werden soll, Punkte mit niedrigerem Volumenwert werden gruppiert. 
		\item Invert Volume - Volumenwert nicht mehr niedriger, sondern größer
		\end{itemize}
\end{itemize}

\subsection*{​Import:}​
\subsubsection*{​Objekt Merge:}
Ermöglicht das zusammenführen mehrerer Geometrien. Dadurch reicht es eine Blüte zu erstellen, die wir in allen Blumen Verwenden Können. Wir Referenzieren dafür auf die Null-Node die am Ende jeder Geometrie liegt. 
Objekt 1 -> klicke auf "Open floating operaor Chooser" -> wähle das Objekt (Null-Nodes

\subsection*{​Labs > WorldBuilding > Tree:}​
\subsection*{​Manipulate:}​
\subsubsection*{​Bend:}
Mit der Transformation Node lässt sich das Objekt verschieben, vergrößern, skalieren und rotieren. Bend kann es dazu noch verformen und zum Beispiel biegen und verdrehen. Durch Setzen des Haken bei "Deform in Both Directions" wird die Verformung in beide Richtungen angewendet, welche als Default nur in eine Richtung geht. Um eine Verformung nutzen zu können, muss diese einfach nur aktiviert werden.
Möglichen Verformungen:
\begin{itemize}
\item Bend - Biegen
\item Twist - Verdrehen
\item Length Scale - strecken(+) und stauchen(-)
\item Taper- Skalieren am Mittelpunkt
\end{itemize}

\subsection*{​Material:}​
\subsection*{​NURBS:}​
\subsubsection*{​Skin:}
setzt eine Haut auf eine Form, die eine Oberfläche definiert. Ebenso kann man auch zwischen zwei Oberflächen eine Haut erstellen. 
Die Anzahl der eingehenden Objekte definiert dabei die Skinning-Methode. Bei nur einem Objekt wird "Linear-skinning" verwendet, welches eine Haut über Querschnitte zieht. Bei mehreren eingehenden Objekt wird "Vilineares Skinning" durchgeführt, welches eine Haut zwischen den Objekten zieht.

\subsection*{​Particle:}​
\subsection*{​Polygon:}
\subsubsection*{​Add:}
mit add kann man entweder Punkte oder ein Polygon erstellen, oder man fügt punkte/Polygone einem Input hinzu.
Points		
\begin{itemize}
\item Number of Points - Anzahl der Punkte
\item PointX	- die drei Felder entsprechen den x,y,z coordinaten
\item w - weight (Gewicht), wenn die Punkte später zu einer spline (NURBS or Bezier) werden, beeinflusst das Gewicht die Form und kann dazu führen das sie rational wird
\end{itemize}
\includegraphics*[width=\textwidth]{graphics/add.JPG}

\subsubsection*{​Boolean:}
Kombiniert entweder zwei Objekte mit Boolean Operatoren oder findet ihre Schnittlinie.

Set	Treat As	Solid	->Festes Objekt
			Surface ->Fläche ohne innen und Außenseite
Funktionen:
\begin{itemize}
\item Set A -> Solid, Set B -> Solid
	\begin{itemize}
	\item Union - neues Festes Objekt mit dem Volumen von beiden gegebenen Objekten
	\item intersect - neues Festes Objekt mit dem gemeinsam genutzten Volumen der gegebenen Objekte
	\item substract - entfernt das geteilte Volumen von einem oder beiden gegebenen Objekten
	\item shatter - Kombination aus Intersect und Subtract: schneidet entlang der Schnittstellen, um neue Objekte zu erstellen
	\item seam - gibt Polylinien aus, an denen sich die Oberflächen schneiden
	\end{itemize}

\item Set A -> Solid, Set B -> surface
	\begin{itemize}
	\item Union - kombiniert ein festes Objekt mit doppelten Wänden um teile der Fläche außerhalb des Volumens des Festen Objekts herum
	\item intersect - schneidet alle Parts der Fläche weg die außerhalb des festen Objekts liegen
	\item substract - beim Subtrahieren einer Fläche von einem festen Objekt entstehen doppelwandige schnitte im festen Objekt, wo er die Objekte schneidet
	\item shatter - Kombination aus Intersect und Subtract: schneidet die Schnittpunkte in eine neue Form
	\item seam - gibt Polylinien aus, wo die Fläche den Festen Objekt schneidet
	\end{itemize}
\item Set A -> surface, Set B -> Solid
	\begin{itemize}
	\item Union - kombiniert zusammentreffende Flächen und deren schneidende Teile der beiden Flächen
	\item intersect - behält nur zusammentreffende Flächen
	\item substract - entfernt zusammentreffende Flächen und erstellt doppelseitige schnitte entlang der Schnittpunkte
	\item shatter - Kombination aus Intersect und Subtract:  schneidet Schnittpunkte heraus und behält zusammentreffende Flächen 
	\item seam - gibt Polygone für zusammentreffende Flächen und Polylinien an den Schnittpunkten aus 
	\end{itemize}
\item custom	- Bei Festen Objekten mit überlappenden oder konzentrischen Flächen kann man Custom nutzen, um einen Bereich an einer gewissen tiefe auszuschneiden
\item detect	- durchläuft die ersten Geometrien und fügt optionale Gruppen und/oder Attribute hinzu, die die sich schneidende Polygone enthalten.
\end{itemize}

\subsubsection*{​PolyBevel:}
\subsubsection*{​PolyExtrude:}​
\subsubsection*{​Remesh:}
Rekreiert die Fläche mit "hochwertigen" (fast gleichseitigen) Dreiecken (hochwertiges dreiecksnetz = alle Winkel so nah wie möglich an 60 Grad). Dabei wird versucht in jedem Dreieck den kleinsten Winkel zu maximieren.
Es gibt zwei Arten von Remeshing:
\begin{itemize}
\item Uniform - versucht Kantenlängen auszugleichen und erstellt so gleichgroße Dreiecke
\item Adaptive - passt die Größe den Bereichen an und erstellt größere Dreiecke in breiten Bereichen und kleinere Dreiecke in detaillierten Bereichen
\end{itemize}
\begin{itemize}
\item Iterations - die Qualität des Netzes, Im Normalfall ist die maximal nützliche Anzahl 3 bis 4
\item Recompute Normals - berechnet neue normals für das generierte netz
\item Smoothing - grad der Glättung
\end{itemize}

\subsubsection*{​Subdivide:}
nimmt eine Polygon Fläche und teilt jeden Bereich, um die Fläche zu glätten.
\begin{itemize}
\item Groups - Alle Polygone in der linken Eingabe, werden verwendet, um das zu unterteilende Polygonnetz zu bestimmen.
\item Creases - Elemente der rechten Eingabe werden als Knicke genutzt.
\item Depth - Wie viele Iterationen zu unterteilen sind
\end{itemize}

\subsection*{​Primitive:}
\subsubsection*{​Grid:}
Erstellt eine flache Ebene, die aus einem Netz, Bezier- und NURBS-Flächen oder mehreren Linien mit offenen Polygonen bestehen kann. Häufig genutzte Parameter:
\begin{​itemize}​
\item Size - Breite und Höhe des Rasters.
\item Rows - Anzahl der Reihen im Raster oder Rumpf.
\item Column - Anzahl der Spalten im Raster oder Rumpf.
\end{​itemize}​

\subsubsection*{​Line:}
Erstellt ein Polygon oder eine Linie.
\begin{​itemize}​
\item Primitive Type	Geometrie Typ  
\item Origin - Start der Linie
\item Direction - Richtung der Linie
\item Length	- Länge der Linie
\item Points	- Anzahl der Punkte mit der die Linie erstellt wird
\end{​itemize}​

\subsubsection*{​L-System:}
Das Lindenmeyer-System ist ein Algorithmus zum Umschreiben von Zeichenfolgen. Einfach gesagt ersetzt der Algorithmus nach einer bestimmten Regel Zeichen durch andere Zeichen bzw. Zeichenketten.
Durch Verwendung von Iterationen, wobei die Ergebnisse zur Grundlage der nächsten Iteration werden, kann man ein Wachstum darstellen. In unserem Fall nutzen wir sie, um Blumen und deren Verzweigungen am Stängel herzustellen. 
\begin{​itemize}​
\item GEOMETRY	\begin{​itemize}​
			\item Type - Skeleton = einfache Linien; Tubes = Röhren
			\item Generation - gibt an wie viele Generationen im Falle einer Iteration durchlaufen werden
			\item Apply Colour - durch setzen werden die Farben der eingefügten Objekte übernommen
		\end{​itemize}​
\item TUBES	\begin{​itemize}​
		\item rows & cols - gibt Anzahl der Reihen und Spalten des "netztes" der Röhren an
		\item Tension - wie gerade die Röhren zu ihrem Zielpunkt gehen
		\item Thickness - breite der Röhre
		\end{​itemize}​
\item RULES		\begin{​itemize}​
			\item Premise - Ausgangszustand des L-Systems - Generation 0
			\item Rule\#   - Regeln/Formeln die den Verlauf des L-Systems beschreiben
		\end{​itemize}​
Befehle die genutzt werden:  
\begin{​itemize}​
\item [] - erstellt ein neuen Branch
\item \{\} - erstellt ein Polygon
\item ABCD - Variablen die für die einzelnen Regeln stehen
\item JKM - verweist auf die Objekte bzw. die Eingänge 
\item F(a) -  rstellt eine einfache Linie. Man kann sie zusätzlich durch einen Wert in einer folge Klammer verkürzen/verlängern
\item .  - Polygon Vertex (Vertex = Ecke eines Polygons)
\item !(s) - Multipliziert momentane breite mit s. In unserem Fall bewirkt es, das die röhren immer schmaler werden
\item \&(a) - nach oben kippen um a grad
\item \^(a) - nach unten kippen um a grad
\item "(s) - multipliziert bzw. skaliert die momentane Branch länge mit s
\item /(a) - dreht im Uhrzeigersinn a grad
\item -(a) - rotiert nach links um a grad
\item +(a) - rotiert nach rechts um a grad
\end{​itemize}​

\subsubsection*{​Tube:}​
\subsection*{​Utility:}​
\subsubsection*{​Convert:}
Konvertiert eine Geometrie Art zu einer anderen Geometrie Art
	\begin{​itemize}​
	From Type	Welche Art die Geometrie hat
	Convert To	Welche Art die Geometire danach haben soll
	\end{​itemize}​
Division per Span
	\begin{​itemize}​
	\item Genaue Anzahl der Punkte
	\item U- Punktdichte in U Richtung
	\item V - Punktdichte in V Richtung
	\item U Order- Spline-Reihenfolge von Kurven und Flächen in U
	\item V Order - Spline-Reihenfolge von Kurven und Flächen in V
	\item Interpolate Through Hulls - Die Form der Geometrie wird übernommen, deaktiviert U & V
	\end{​itemize}​

\subsubsection*{​Copy:}
Copy besitzt zwei Hauptaufgaben:
- mehrere Kopien einer Geometrie erstellen
- Kopiert die erste Geometrie an Punkte der Zweiten Geometrie
Die einzelnen Kopien können zusätzlich mit COPY transformiert werden. 
Durch STAMP -> Stamp Inputs können Variablen für jede Kopie weitergeführt werden. 

\subsubsection*{​Copy to points:}
Wie der Name schon sagt, kopiert es ein Objekt (erster Input) and übergebene Punkte (zweiter Input). Wird in unserem Fall innerhalb einer Schleife genutzt

\subsubsection*{​Mirror:}
Dupliziert und spiegelt das Objekt. 

\subsubsection*{​Null:}
Das Null Objekt dient zum einen als Platzhalter. Es kann verwendet werden, um einen Ort im Raum der Scene zu bestimmen oder als "Betrachtungsobjekt" als Hilfe für die Koordination in der Szene. Seine Parameter ähneln denen von "Transformieren und "Verschiedenes". Es kann ein Objekt Transformieren und hilft später besser auf das Objekt referenzieren zu können

\subsubsection*{​For Each (begin & End):}
For Each beinhaltet zwei Nodes: begin und end. Der Context der Schleife steht in der Input-Node der begin-Node, was in unserem Fall unsere Punkte sind. Die For Each Schleife geht nun jeden Punkt durch und wendet die Nodes die zwischen begin und end liegen auf jeden dieser Punkte an.


\section*{​\textcolor{​rosa}​{​Tutorials:}​}​
\subsection*{​Terrain:}​
\subsection*{​Wasser:}​
\subsection*{​Gras:}​



\subsection*{​Blumen:}
\subsubsection*{​Blüte:}
\includegraphics*[width=\textwidth]{graphics/blossom.JPG}
Um eine einfache Blüte zu machen, brauchen wir nur eins: ein Blatt. Um ein Blatt zu erstellen, brauchen wir erstmal zwei Linien. Line2(Direktion (0;0;1); Length 0.9; Points 8) bildet die Hauptader des Blattes. Ihr fügen wir die Attribute zum Verformen des Blattes wie z.b. die Rotation, Skalierung usw. mit Hilfe der Node Attribwrangle hinzu.
\begin{lstlisting}
	f@np= @ptnum/(@numpt*1.0);     	 	->np = aktuelle punkt / (anzahl pkt * 1.0)
	f@rot= chramp('rot',@np); 			->erstellt ramp zur rotation (später bei Copy)
	f@sc = chramp('sc',@np);				->erstellt ramp zur skalierung
	@pscale = @sc;					->setzt skalierung = sc
	f@curve_loc = chramp('curve_loc',@np); 	->curve loc ramp  (später bei Line1 und Copy)
	f@screw_loc = chramp('screw_loc',@np);	->screw loc ramp
\end{lstlisting} 
\includegraphics*[width=\textwidth]{graphics/attrbwranglewerte.JPG}
durch sie können wir das Blatt nachher nach unseren Bedürfnissen anpassen und verformen, wodurch sich viele verschieden Blüten bilden lassen würden. In unserem Fall bleiben wir bei einem Design, da unser Stil LowPoly ist. Da es bei den Linien schwer ist zu erkennen wie das Blatt im Nachhinein aussehen wird, werden wir die Attribute erst später genauer setzen.
Line1(Direction(1;0;0); Length 0.46; Points 3) stellen die Nebenadern dar. Ihr geben wir mit Attribcreate ein weites Attribut namens curve_loc_to_vop, dessen Betrag wir der später folgenden Copy Node entnehmen und daher erst später setzen. Die Linie hat später einen Knick, wodurch sich eine Delle im Blatt bildet.
Dieses Attribut bearbeiten wir mit AttribVOP um die werte der Position des Knicks anzupassen. Dazu nehmen wir die Position des Punktes und lassen x und z unberührt. y berechnen wir neu. Dazu nehmen wir den aktuellen punkt (ptnum), wandeln ihn zu einem float um (inttofloat) und teilen (divide) ihn durch die Anzahl der Punkte (numpt), welche durch (divconst) 1.192 geteilt wurde. Das Ergebnis geht in eine Ramp (Ramp) und wird anschließend mit dem Attribut curve_loc_to_cop (bind) multipliziert. Durch Verändern der Konstante verändert sich der dadurch entstandenen knick. 
\includegraphics*[width=\textwidth]{graphics/attribvop.JPG}
Anschließend nutzen wir copy um Line1 an die Punkte der Line2 setzen. Hier legen wir jetzt unter Stamp die bereits erwähnte curve_loc Variable (Variable:c_loc; Value:@curve_loc) an. Die Linien lassen wir dazu noch rotieren um eben die Form eines Blattes zu bekommen. Dazu geben wir unter Copy dem y Wert von Rotate den wert "fit01(@rot,90,-90)". Fertig is das Skelet des Blattes.
\includegraphics*[width=\textwidth]{graphics/blossom1.JPG}
Um es jetzt zu einem Blatt zu machen, legen wir eine Haut (skin) drüber und spiegeln (mirror) es. Jetzt können wir zurück zu attribVOP gehe und die Ramps nach Belieben ändern. Optional kann das Blatt noch etwas gebogen (bend (Bend -53.8)) werden. 
\includegraphics*[width=\textwidth]{graphics/blossom2.JPG}
\includegraphics*[width=\textwidth]{graphics/blossom3.JPG}
Jetzt muss das Blatt nur noch in einem Kreis positioniert werden und fertig ist die Blüte.
Dazu geben wir dem Blatt noch eine Transform Node mit in der wir bei Rotate y den wert "point("../foreach_begin", 0, "roff", 0)" geben. Auf den greifen wir gleich innerhalb der Schleife, um die blätter mit zu rotieren.
Als erstes erstellen wir eine For Each Schleife. In begin kommt ein attribwrangle.
\begin{lstlisting}
	int pnt = addpoint(0, {0,0,0});
	float roff = chf("Angle") * @elemnum;
	setpointattrib(0, "roff", pnt, roff, "set");
\end{lstlisting} 
wir legen also punkte an, die alle bei 0,0,0 liegen an die die Blätter gesetzt werden, aber lassen das Blatt bei jedem Punkt rotieren (roff). Oberhalb gibt Number count (9) an wie viele Blüten Blätter erstellt werden. Unterhalb kann man mit Angle (160) den Winkel anpassen. Wenn man mehr oder weniger Blüten Blätter haben will, muss man den Winkel immer wieder neu anpassen. 
Zwischen Begin und End kommt nun ein copy to points, dessen erster Input unser Blatt, zweiter Input Begin und output End ist. Dadurch wird an jeden Punkt ein Blüten Blatt kopiert und dessen rotation gesetzt. 
Zum Abschluss setzen wir eine Null Node die wir BLOSSOM_OUT nennen, um später einfacher auf die Blüte zugreifen zu können.  

\includegraphics*[width=\textwidth]{graphics/blossom4.JPG}
Fertig ist unsere Blüte.

\subsubsection*{​Blatt:}
Das Blatt könnte man jetzt auf dieselbe weise wie das Blüten Blatt machen, da die Blätter am Stängel aber weniger wichtiger sind gestalten wir dies etwas einfacher. Dazu nutzen wir L-Systeme.
\begin{lstlisting}
	Premise	[A][B]
	Rule 1	A=[+A{.].C.}
	Rule 2	B=[-B{.].C.}
	Rule 3	C=FFFC
\end{lstlisting} 
\includegraphics*[width=\textwidth]{graphics/leaf1.JPG}
dazu erstellen wir Polygone (geometrische Figuren). Später Innerhalb der Flume Verformen wir das Blatt, um es natürlicher aussehen zu lassen.
Am Ende erstellen wir wieder eine Null Node LEAF_OUT.


\subsubsection*{​Kern:}
Da wir uns ja im LowPoly befindet, hab ich anstatt der größeren Anzahl an Kernen nur eine Sphere genommen, diese etwas verkleinert (Uniform Scale 0.2) und gestaucht (Radius(0;0.4;0)) und später innerhalb der Blume braun gefärbt. Den Schluss bildet wieder eine Null Node KERNEL_OUT.
Wenn man aber die Blume detaillierter darstellen möchte, sollte man auf die Anordnung der Kerner, welche sich Phyllotaxis nennt, achten. Diese bezieht sich auch die Blüten Blätter. 
\begin{lstlisting}
	int num = chf("num");
	float phi = (1 *sqrt(5) / 2.0;
	float ang = 2* \$PI * (phi - 1) /phi;

	for(int i=0; i<num; i++)
	{
		float rad = i;
		vector pos = set(cos(ang * i) * rad, 0, sin(ang*1) * rad;
		int pt = addpoint(0, pos);
	}	
\end{lstlisting} 
\subsubsection*{​Blume:}
\includegraphics*[width=\textwidth]{graphics/flower_three.JPG}
Jetzt brauchen wir nur noch alles zusammenzufügen und unsere L-Systeme zu erstellen. 
Um auf unsere Objekte zuzugreifen nutzen wir Object Merge. Dazu geben wir ihm unter Object1 jeweils eine Null Node. Jedem Object Merge hab ich jeweils noch ein Transform angehängt, um die einzelne Objekte anpassen zu können. Dem Blatt hab ich zusätzlich noch ein bend(Bend 22.5; Twist 55) gegeben, um es natürlicher wirken zu lassen.
Die Objekte bilden den Input für unsere L Systeme (J = Blüte; K = Blatt; M = Kern)
\includegraphics*[width=\textwidth]{graphics/flowerone1.JPG}
\begin{lstlisting}[caption={Flower One}]
	Premise !F(0.07)[B]!F(0.07)[E]!F(0.07)A
	Rule 1	A=!\\"[B]///[B]///[B]///[B]
	Rule 2	B=!-(20)\&F(0.05)C
	Rule 3	C=!\\"[D]//[D]//[D]//[D]//[D]//[D]F(0.04)J
	Rule 4	D=!-(20)\&F(0.04)J
	Rule 5	E=!-(20)\^F(0.05)C
\end{lstlisting} 
\includegraphics*[width=\textwidth]{graphics/flowertwo1.JPG}
\begin{lstlisting}[caption={Flower Two}]
	Premise F(0.05)A
	Rule 1	A = -(15)!F(0.05)[\^BBBBK]/(120)!F(0.03)[\^CCCJM]A
	Rule 2	B = -(20)!\&(10)F(0.004)
	Rule 3	C = -(10)!\^(10)F(0.02)
	Rule 4	D = -(15)!F(0.05)[\^BBBBK]/(120)[\^CCCJ]A
\end{lstlisting} 
Bei der zweiten Blume bildete sich ein Problem. Sie besteht aus Iterationen, wodurch man durch Verändern der Anzahl der Generationen ein Wachstum sehen kann. Das Problem: die Objekte bilden sich sofort, wodurch es zu einem unschönen Bild wurde. Das neue Blatt und die Blüte hangen ineinander. Durch einfügen einer Linie (Regel A; F(0.03)) sieht es aber Akzeptabel aus. 
\includegraphics*[width=\textwidth]{graphics/flowerthree1.JPG}
\begin{lstlisting}[caption={Flower Three}]
	Premise !/(395)F!/(100)F[CCCK]/(196)F[CCCK]!/(183)F[AAAMJ]
	Rule 1	A = -(20)!F(0.02)
	Rule 2	B = -(20)!\^(20)F(0.02)
	Rule 3	C = -(20)!\&(20)F(0.02)
\end{lstlisting} 
\includegraphics*[width=\textwidth]{graphics/flowerfour1.JPG}
\begin{lstlisting}[caption={Flower Four}]
	Premise FA
	Rule 1	A=!"[B]////[B]////BJ
	Rule 2	B=!\&FA
\end{lstlisting} 
Mit Hilfe von Gruppen können wir die Blume nun einfärben (color). Erstmal färben wir alles Grün (#21FF26), ohne eine Gruppe anzugeben. Die Blüte und den Kern färben wir durch Angeben der Gruppen lsysX, wobei X der jeweilige Input steht (Blüte = J; Kern = M). An Ende wie immer unser Null Node FLOWER_OUT

\subsection*{​Bäume:}​


\end{document}